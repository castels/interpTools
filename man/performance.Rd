% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/performance.R
\name{performance}
\alias{performance}
\title{Evaluate Interpolation Performance Across Multiple Time Series}
\usage{
performance(OriginalData, IntData, GappyData, custom = NULL)
}
\arguments{
\item{OriginalData}{\code{list}; A list object of dimension D x N of original (complete) time series}

\item{IntData}{\code{list}; A list object of dimension D x M x P x G x K x N of interpolated time series (output of parInterpolate.R)}

\item{GappyData}{\code{list}; A list object of dimension D x P x G x K x N of the gappy original time series (output of simulateGaps.R)}

\item{custom}{\code{character}; A vector of names of user-defined functions used to calculate custom performance metrics (see details)}
}
\description{
Function to calculate the performance metrics between lists of original and interpolated series. \cr \cr
See \code{?eval_performance} and additional documentation provided in this package (\code{"~/metric_definitions.pdf/"}) for a full list and description of the the performance criteria.\cr
Resulting object is of class '\code{pf}'.
}
\examples{
 # User-defined functions to calculate a custom performance metric (see Details for rules)
 
 my_metric1 <- function(x,X){
 
  # Sum of original + interpolated values
  
  val <- x + X
  
  return(val) # return value must be a single numeric element
  
  }
  
 my_metric2 <- function(x,X){
 
  # Sum of index positions of interpolated values
 
  val <- sum(which(x != X))
 
  return(val) # return value must be a single numeric element
 
 } 
 
 # Implementing in eval_performance()
 
 performance(OriginalData = OriginalData, IntData = IntData, GappyData = GappyData, custom = c("my_metric1", "my_metric2"))

}
